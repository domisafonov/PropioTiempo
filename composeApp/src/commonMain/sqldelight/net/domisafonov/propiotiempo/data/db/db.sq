import kotlinx.datetime.Instant;

-- must be referenced with older_version _at most_ 1 time
-- being referenced with older_version implies is_enabled=0
CREATE TABLE activities (
  id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  older_version INTEGER,
  is_enabled INTEGER,
  FOREIGN KEY(older_version) REFERENCES activities(id) ON DELETE SET NULL ON UPDATE RESTRICT
);
CREATE INDEX activities_names ON activities (name);
CREATE UNIQUE INDEX activities_older_versions ON activities (older_version);

CREATE TABLE time_activities (
  id INTEGER NOT NULL PRIMARY KEY,
  FOREIGN KEY(id) REFERENCES activities(id) ON DELETE CASCADE ON UPDATE RESTRICT
);

CREATE TABLE daily_checklist (
  id INTEGER NOT NULL PRIMARY KEY,
  FOREIGN KEY(id) REFERENCES activities(id) ON DELETE CASCADE ON UPDATE RESTRICT
);

CREATE TABLE daily_checklist_items (
  id TEXT NOT NULL PRIMARY KEY, -- UUID
  checklist_id INTEGER NOT NULL,
  ordinal INTEGER NOT NULL,
  name TEXT,
  FOREIGN KEY(checklist_id) REFERENCES daily_checklist(id) ON DELETE CASCADE ON UPDATE RESTRICT
) WITHOUT ROWID;
CREATE UNIQUE INDEX daily_checklist_item_order ON daily_checklist_items (checklist_id, ordinal);

CREATE TABLE time_activity_intervals (
  activity_id INTEGER NOT NULL,
  start_time INTEGER AS Instant NOT NULL,
  end_time INTEGER AS Instant,
  PRIMARY KEY(activity_id, start_time),
  FOREIGN KEY(activity_id) REFERENCES time_activities(id) ON DELETE CASCADE ON UPDATE RESTRICT
) WITHOUT ROWID;

CREATE TABLE daily_checklist_checks (
  daily_checklist_item_id TEXT NOT NULL,
  time INTEGER AS Instant NOT NULL,
  PRIMARY KEY(daily_checklist_item_id, time),
  FOREIGN KEY(daily_checklist_item_id) REFERENCES daily_checklist_items(id) ON DELETE CASCADE ON UPDATE RESTRICT
) WITHOUT ROWID;

-- TODO: remove test data
INSERT INTO activities VALUES(1, 'emptyone', NULL, TRUE);
INSERT INTO activities VALUES(2, 'hasdatatwo', NULL, TRUE);
INSERT INTO activities VALUES(3, 'oldthree', NULL, FALSE);
INSERT INTO activities VALUES(4, 'newfour', 3, TRUE);

INSERT INTO time_activities VALUES (1);
INSERT INTO time_activities VALUES (2);
INSERT INTO time_activities VALUES (3);
INSERT INTO time_activities VALUES (4);

INSERT INTO time_activity_intervals VALUES (2, 1746304935, 1746305935);
INSERT INTO time_activity_intervals VALUES (2, 1746204935, 1746205935);

INSERT INTO time_activity_intervals VALUES (3, 1746305035, 1746305935);
INSERT INTO time_activity_intervals VALUES (4, 1746305936, 1746306000);
-- TODO: end remote test data

get_inserted_autoid:
SELECT last_insert_rowid();

insert_activity:
INSERT INTO activities(name, older_version) VALUES(?, ?);

insert_time_activity:
INSERT INTO time_activities VALUES(?);

insert_daily_checklist:
INSERT INTO daily_checklist VALUES(?);

insert_daily_checklist_item:
INSERT INTO daily_checklist_items VALUES(?, ?, ?, ?);

insert_daily_checklist_check:
INSERT INTO daily_checklist_checks VALUES(?, ?);

get_daily_checklist_summary:
SELECT
  a.id AS id,
  a.name AS name,
  (count(i.id) - count(cc.daily_checklist_item_id)) = 0 AS is_completed
  FROM daily_checklist AS c
  INNER JOIN activities AS a ON c.id = a.id
  LEFT JOIN daily_checklist_items AS i ON c.id = i.checklist_id
  LEFT JOIN daily_checklist_checks AS cc ON i.id = cc.daily_checklist_item_id
  WHERE
    a.is_enabled = TRUE
    AND cc.time >= :day_start
  GROUP BY a.id
  ORDER BY a.name;

get_time_activities_summary:
SELECT
  a.id AS id,
  a.name AS name,
  total(
    ifnull(i.end_time, unixepoch())
      - max(:day_start, ifnull(i.start_time, :day_start))
  ) AS sum
  FROM time_activities AS ta
  INNER JOIN activities AS a ON ta.id = a.id
  LEFT JOIN time_activity_intervals AS i ON ta.id = i.activity_id
  WHERE
    a.is_enabled = TRUE
    AND (i.end_time IS NULL OR i.end_time >= :day_start)
  GROUP BY a.id
  ORDER BY a.name;
